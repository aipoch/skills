#!/usr/bin/env python3
"""
Circos Plot Generator
Simplifies creation of Circos configuration files for genomics visualization.
"""

import argparse
import csv
import os
import sys
from pathlib import Path
from typing import Dict, List, Optional, Any
import json

# Color schemes
COLOR_SCHEMES = {
    "default": ["red", "blue", "green", "orange", "purple", "cyan"],
    "nature": ["#E64B35", "#4DBBD5", "#00A087", "#3C5488", "#F39B7F", "#8491B4"],
    "lancet": ["#00468B", "#ED0000", "#42B540", "#0099B4", "#925E9F", "#FDAF91"],
    "cell": ["#1B9E77", "#D95F02", "#7570B3", "#E7298A", "#66A61E", "#E6AB02"],
}

# Chromosome sizes (GRCh38/hg38)
CHROMOSOME_SIZES = {
    "chr1": 248956422, "chr2": 242193529, "chr3": 198295559,
    "chr4": 190214555, "chr5": 181538259, "chr6": 170805979,
    "chr7": 159345973, "chr8": 145138636, "chr9": 138394717,
    "chr10": 133797422, "chr11": 135086622, "chr12": 133275309,
    "chr13": 114364328, "chr14": 107043718, "chr15": 101991189,
    "chr16": 90338345, "chr17": 83257441, "chr18": 80373285,
    "chr19": 58617616, "chr20": 64444167, "chr21": 46709983,
    "chr22": 50818468, "chrX": 156040895, "chrY": 57227415,
}


class CircosConfig:
    """Generate Circos configuration files."""
    
    def __init__(self, config: Dict[str, Any]):
        self.config = config
        self.output_dir = Path(config.get("output", "."))
        self.data_dir = self.output_dir / "data"
        self.colors = COLOR_SCHEMES.get(config.get("color_scheme", "default"), COLOR_SCHEMES["default"])
        
    def generate(self) -> str:
        """Generate complete Circos configuration."""
        self.output_dir.mkdir(parents=True, exist_ok=True)
        self.data_dir.mkdir(parents=True, exist_ok=True)
        
        config_parts = [
            self._generate_header(),
            self._generate_ideogram(),
            self._generate_ticks(),
            self._generate_colors(),
        ]
        
        plot_type = self.config.get("type", "variation")
        if plot_type == "variation":
            config_parts.append(self._generate_variation_tracks())
        elif plot_type == "cell-comm":
            config_parts.append(self._generate_cell_comm_tracks())
        else:
            config_parts.append(self._generate_custom_tracks())
            
        config_parts.append(self._generate_footer())
        
        config_content = "\n".join(config_parts)
        config_path = self.output_dir / "circos.conf"
        config_path.write_text(config_content)
        
        return str(config_path)
    
    def _generate_header(self) -> str:
        """Generate configuration header."""
        title = self.config.get("title", "Circos Plot")
        width = self.config.get("width", 800)
        height = self.config.get("height", 800)
        
        return f"""# Circos Configuration
# Generated by Circos Plot Generator
# Title: {title}

# Image settings
<image>
<<include etc/image.conf>>
dir   = .
file  = circos.png
png   = yes
svg   = yes
width = {width}
height = {height}
</image>

# Karyotype (chromosome definitions)
<<include etc/colors_fonts_patterns.conf>>
<<include etc/housekeeping.conf>>
"""

    def _generate_karyotype(self, chromosomes: Optional[List[str]] = None) -> str:
        """Generate karyotype file for chromosomes."""
        if chromosomes is None:
            chromosomes = list(CHROMOSOME_SIZES.keys())
        
        karyotype_lines = []
        for chrom in chromosomes:
            if chrom in CHROMOSOME_SIZES:
                size = CHROMOSOME_SIZES[chrom]
                karyotype_lines.append(f"chr - {chrom} {chrom} 0 {size} chr{chrom[-1] if chrom[-1].isdigit() else chrom[-1]}")
        
        karyotype_content = "\n".join(karyotype_lines)
        karyotype_path = self.data_dir / "karyotype.txt"
        karyotype_path.write_text(karyotype_content)
        
        return f'karyotype = {karyotype_path}'
    
    def _generate_ideogram(self) -> str:
        """Generate ideogram (chromosome visualization) configuration."""
        return """
<ideogram>
<spacing>
default = 0.005r
</spacing>

thickness        = 25p
stroke_thickness = 2
stroke_color     = black
fill             = yes
fill_color       = black

show_label       = yes
label_font       = default
label_radius     = dims(ideogram,radius) + 0.075r
label_size       = 30p
label_parallel   = yes

show_bands            = yes
fill_bands            = yes
band_stroke_thickness = 2
band_stroke_color     = white
</ideogram>
"""

    def _generate_ticks(self) -> str:
        """Generate tick marks configuration."""
        return """
<ticks>
radius           = 1r
color            = black
thickness        = 2p

multiplier       = 1e-6
format           = %d

<tick>
spacing        = 5u
size           = 10p
show_label     = yes
label_size     = 15p
label_offset   = 5p
format         = %d
</tick>

<tick>
spacing        = 25u
size           = 15p
show_label     = yes
label_size     = 20p
label_offset   = 5p
format         = %d
</tick>
</ticks>
"""

    def _generate_colors(self) -> str:
        """Generate custom colors configuration."""
        colors = []
        for i, color in enumerate(self.colors):
            colors.append(f"color{i} = {color}")
        return "<colors>\n" + "\n".join(colors) + "\n</colors>\n"
    
    def _generate_variation_tracks(self) -> str:
        """Generate tracks for genomic variation visualization."""
        data_file = self.config.get("data")
        
        tracks = []
        
        # Process data file if provided
        if data_file and os.path.exists(data_file):
            self._process_variation_data(data_file)
            
            # Generate histogram track
            tracks.append("""
<plot>
type             = histogram
file             = data/variations.txt
r1               = 0.95r
r0               = 0.75r
fill_color       = color0
stroke_color     = black
stroke_thickness = 1
extend_bin       = no
<axes>
<axis>
color     = lgrey
thickness = 1
position  = 0.5
</axis>
</axes>
</plot>
""")
            
            # Generate link track for structural variants
            tracks.append("""
<links>
<link>
file             = data/links.txt
radius           = 0.7r
bezier_radius    = 0.2r
color            = color1
thickness        = 2
</link>
</links>
""")
        
        return "\n".join(tracks)
    
    def _process_variation_data(self, data_file: str):
        """Process variation data from CSV."""
        variations = []
        links = []
        
        with open(data_file, 'r') as f:
            reader = csv.DictReader(f)
            for row in reader:
                chrom = row.get('chrom', '')
                start = row.get('start', '0')
                end = row.get('end', '0')
                var_type = row.get('type', 'SNP')
                value = row.get('value', '1')
                
                if chrom and start and end:
                    variations.append(f"{chrom}\t{start}\t{end}\t{value}")
                    
                    # Create links for structural variants
                    if var_type.upper() in ['TRANSLOCATION', 'INVERSION', 'DELETION', 'DUPLICATION']:
                        target_chrom = row.get('target_chrom', chrom)
                        target_start = row.get('target_start', start)
                        target_end = row.get('target_end', end)
                        links.append(f"{chrom}\t{start}\t{end}\t{target_chrom}\t{target_start}\t{target_end}")
        
        # Write variations
        var_path = self.data_dir / "variations.txt"
        var_path.write_text("\n".join(variations))
        
        # Write links
        links_path = self.data_dir / "links.txt"
        links_path.write_text("\n".join(links))
    
    def _generate_cell_comm_tracks(self) -> str:
        """Generate tracks for cell-cell communication visualization."""
        data_file = self.config.get("data")
        
        # Create cell type karyotype
        if data_file and os.path.exists(data_file):
            cell_types, connections = self._process_cell_comm_data(data_file)
            
            # Write custom karyotype for cells
            karyotype_lines = []
            for i, cell_type in enumerate(cell_types):
                color_idx = i % len(self.colors)
                karyotype_lines.append(f"chr - {cell_type} {cell_type} 0 100 color{color_idx}")
            
            karyotype_path = self.data_dir / "karyotype.txt"
            karyotype_path.write_text("\n".join(karyotype_lines))
            
            # Generate ribbon tracks for connections
            return f"""
karyotype = {karyotype_path}

<links>
ribbon           = yes
flat             = yes
<link>
file             = data/cell_connections.txt
radius           = 0.95r
stroke_thickness = 2
stroke_color     = black
color            = grey_a5
</link>
</links>

<plots>
<plot>
type         = text
file         = data/cell_labels.txt
r0           = 1.05r
r1           = 1.2r
show_links   = yes
link_dims    = 0p,0p,40p,0p,10p
link_thickness = 2p
link_color   = black
label_size   = 24p
label_font   = condensed
padding      = 5p
rpadding     = 5p
</plot>
</plots>
"""
        return ""
    
    def _process_cell_comm_data(self, data_file: str) -> tuple:
        """Process cell-cell communication data."""
        cell_types = set()
        connections = []
        
        with open(data_file, 'r') as f:
            reader = csv.DictReader(f)
            for row in reader:
                source = row.get('source', '')
                target = row.get('target', '')
                weight = row.get('weight', '1')
                
                if source and target:
                    cell_types.add(source)
                    cell_types.add(target)
                    
                    # Normalize weight for ribbon size
                    weight_val = float(weight) * 100
                    connections.append(f"{source}\t0\t{weight_val}\t{target}\t0\t{weight_val}")
        
        # Write connections
        conn_path = self.data_dir / "cell_connections.txt"
        conn_path.write_text("\n".join(connections))
        
        # Write labels
        labels = [f"{ct}\t50\t{ct}" for ct in cell_types]
        labels_path = self.data_dir / "cell_labels.txt"
        labels_path.write_text("\n".join(labels))
        
        return sorted(list(cell_types)), connections
    
    def _generate_custom_tracks(self) -> str:
        """Generate custom tracks from configuration."""
        tracks_config = self.config.get("tracks", [])
        tracks = []
        
        for i, track in enumerate(tracks_config):
            track_type = track.get("type", "histogram")
            track_file = track.get("file", f"data/track_{i}.txt")
            color = track.get("color", f"color{i % len(self.colors)}")
            
            if track_type == "histogram":
                tracks.append(f"""
<plot>
type             = histogram
file             = {track_file}
r1               = {0.95 - i*0.15}r
r0               = {0.80 - i*0.15}r
fill_color       = {color}
stroke_color     = black
stroke_thickness = 1
</plot>
""")
            elif track_type == "link":
                tracks.append(f"""
<links>
<link>
file             = {track_file}
radius           = {0.75 - i*0.1}r
color            = {color}
thickness        = 2
</link>
</links>
""")
        
        return "\n".join(tracks)
    
    def _generate_footer(self) -> str:
        """Generate configuration footer."""
        # Add karyotype reference
        karyotype_path = self.data_dir / "karyotype.txt"
        if karyotype_path.exists():
            return f"\n# Karyotype\nkaryotype = {karyotype_path}\n"
        else:
            # Use default chromosomes
            default_karyotype = self._generate_karyotype()
            return f"\n# Karyotype\n{default_karyotype}\n"


def create_sample_data(output_dir: str, data_type: str = "variation"):
    """Create sample data files for testing."""
    output_path = Path(output_dir)
    output_path.mkdir(parents=True, exist_ok=True)
    
    if data_type == "variation":
        # Sample genomic variation data
        sample_data = """chrom,start,end,type,value,target_chrom,target_start,target_end
chr1,1000000,2000000,SNP,0.5,,
chr1,5000000,6000000,CNV,-0.8,,
chr2,1000000,1500000,SNP,0.3,,
chr2,8000000,10000000,TRANSLOCATION,,chr5,5000000,7000000
chr3,2000000,4000000,INVERSION,,,
chr5,5000000,7000000,TRANSLOCATION,,chr2,8000000,10000000
chr7,1500000,2500000,DUPLICATION,1.2,,
chrX,5000000,8000000,DELETION,-1.0,,
"""
        sample_file = output_path / "sample_variations.csv"
    else:  # cell-comm
        # Sample cell-cell communication data
        sample_data = """source,target,weight,type
T_Cell,Macrophage,0.8,Ligand-Receptor
T_Cell,B_Cell,0.6,Secreted
Macrophage,T_Cell,0.7,Ligand-Receptor
B_Cell,T_Cell,0.5,Secreted
NK_Cell,Tumor_Cell,0.9,Ligand-Receptor
Tumor_Cell,Macrophage,0.4,Secreted
Dendritic_Cell,T_Cell,0.85,Ligand-Receptor
Fibroblast,Tumor_Cell,0.3,Secreted
"""
        sample_file = output_path / "sample_cell_comm.csv"
    
    sample_file.write_text(sample_data)
    print(f"Sample data created: {sample_file}")
    return str(sample_file)


def main():
    """Main entry point."""
    parser = argparse.ArgumentParser(
        description="Generate Circos configuration files for genomics visualization",
        formatter_class=argparse.RawDescriptionHelpFormatter,
        epilog="""
Examples:
  # Generate from variation data
  python main.py --data variants.csv --type variation --output ./plots

  # Generate cell-cell communication plot
  python main.py --data cell_comm.csv --type cell-comm --output ./cell_plots

  # Generate sample data
  python main.py --create-sample variation --output ./data
  python main.py --create-sample cell-comm --output ./data
        """
    )
    
    parser.add_argument("--config", "-c", help="Configuration YAML file")
    parser.add_argument("--data", "-d", help="Input data CSV file")
    parser.add_argument("--type", "-t", choices=["variation", "cell-comm", "custom"],
                       default="variation", help="Plot type")
    parser.add_argument("--output", "-o", default=".", help="Output directory")
    parser.add_argument("--title", default="Circos Plot", help="Plot title")
    parser.add_argument("--width", type=int, default=800, help="Image width")
    parser.add_argument("--height", type=int, default=800, help="Image height")
    parser.add_argument("--color-scheme", choices=list(COLOR_SCHEMES.keys()),
                       default="default", help="Color scheme")
    parser.add_argument("--create-sample", choices=["variation", "cell-comm"],
                       help="Create sample data file")
    parser.add_argument("--render", action="store_true",
                       help="Attempt to render with Circos (requires Circos installation)")
    
    args = parser.parse_args()
    
    # Create sample data if requested
    if args.create_sample:
        sample_file = create_sample_data(args.output, args.create_sample)
        print(f"Use this file with: python main.py --data {sample_file} --type {args.create_sample}")
        return 0
    
    # Build configuration
    config = {
        "type": args.type,
        "title": args.title,
        "width": args.width,
        "height": args.height,
        "color_scheme": args.color_scheme,
        "output": args.output,
    }
    
    if args.data:
        config["data"] = args.data
    
    if args.config:
        import yaml
        with open(args.config, 'r') as f:
            config.update(yaml.safe_load(f))
    
    # Generate Circos configuration
    generator = CircosConfig(config)
    config_path = generator.generate()
    
    print(f"Circos configuration generated: {config_path}")
    print(f"Data files location: {generator.data_dir}")
    
    # Attempt to render if requested
    if args.render:
        import subprocess
        try:
            result = subprocess.run(
                ["circos", "-conf", config_path],
                capture_output=True,
                text=True,
                cwd=args.output
            )
            if result.returncode == 0:
                print(f"Plot rendered successfully!")
                print(f"Output: {Path(args.output) / 'circos.png'}")
            else:
                print(f"Circos rendering failed: {result.stderr}")
                print("You may need to install Circos: conda install -c bioconda circos")
        except FileNotFoundError:
            print("Circos not found. To render the plot, install Circos:")
            print("  conda install -c bioconda circos")
            print("\nConfiguration files are ready. You can render manually:")
            print(f"  cd {args.output} && circos -conf circos.conf")
    else:
        print("\nTo render the plot, install Circos:")
        print("  conda install -c bioconda circos")
        print(f"Then run: cd {args.output} && circos -conf circos.conf")
    
    return 0


if __name__ == "__main__":
    sys.exit(main())
